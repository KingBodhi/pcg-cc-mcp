//! Workflow Artifact model for storing generated conference content
//!
//! Stores articles, thumbnails, social graphics, and social posts generated
//! by the conference workflow pipeline.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{FromRow, SqlitePool};
use thiserror::Error;
use ts_rs::TS;
use uuid::Uuid;

#[derive(Debug, Error)]
pub enum WorkflowArtifactError {
    #[error(transparent)]
    Database(#[from] sqlx::Error),
    #[error("Workflow artifact not found")]
    NotFound,
}

/// Type of artifact generated by the workflow
#[derive(Debug, Clone, Copy, Serialize, Deserialize, TS, PartialEq, Eq)]
#[ts(export)]
#[serde(rename_all = "snake_case")]
pub enum ArtifactType {
    Article,
    Thumbnail,
    SocialGraphic,
    SocialPost,
}

impl std::fmt::Display for ArtifactType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ArtifactType::Article => write!(f, "article"),
            ArtifactType::Thumbnail => write!(f, "thumbnail"),
            ArtifactType::SocialGraphic => write!(f, "social_graphic"),
            ArtifactType::SocialPost => write!(f, "social_post"),
        }
    }
}

/// Workflow artifact record
#[derive(Debug, Clone, FromRow, Serialize, Deserialize, TS)]
#[ts(export)]
pub struct WorkflowArtifact {
    pub id: Uuid,
    pub workflow_id: Uuid,
    pub artifact_type: String,
    pub title: String,
    pub content: Option<String>,
    pub file_url: Option<String>,
    pub metadata: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Create a new workflow artifact
#[derive(Debug, Deserialize, TS)]
#[ts(export)]
pub struct CreateWorkflowArtifact {
    pub workflow_id: Uuid,
    pub artifact_type: ArtifactType,
    pub title: String,
    pub content: Option<String>,
    pub file_url: Option<String>,
    pub metadata: Option<serde_json::Value>,
}

/// Summary of a workflow artifact (for listing)
#[derive(Debug, Clone, Serialize, Deserialize, TS)]
#[ts(export)]
#[serde(rename_all = "camelCase")]
pub struct WorkflowArtifactSummary {
    pub id: Uuid,
    pub artifact_type: String,
    pub title: String,
    pub file_url: Option<String>,
    pub created_at: DateTime<Utc>,
}

impl WorkflowArtifact {
    /// Create a new artifact
    pub async fn create(
        pool: &SqlitePool,
        data: CreateWorkflowArtifact,
    ) -> Result<Self, WorkflowArtifactError> {
        let id = Uuid::new_v4();
        let artifact_type = data.artifact_type.to_string();
        let metadata = data.metadata.map(|v| v.to_string());

        let artifact = sqlx::query_as::<_, WorkflowArtifact>(
            r#"
            INSERT INTO workflow_artifacts (
                id, workflow_id, artifact_type, title, content, file_url, metadata
            )
            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
            RETURNING *
            "#,
        )
        .bind(id)
        .bind(data.workflow_id)
        .bind(&artifact_type)
        .bind(&data.title)
        .bind(&data.content)
        .bind(&data.file_url)
        .bind(metadata)
        .fetch_one(pool)
        .await?;

        Ok(artifact)
    }

    /// Find an artifact by ID
    pub async fn find_by_id(pool: &SqlitePool, id: Uuid) -> Result<Self, WorkflowArtifactError> {
        sqlx::query_as::<_, WorkflowArtifact>(r#"SELECT * FROM workflow_artifacts WHERE id = ?1"#)
            .bind(id)
            .fetch_optional(pool)
            .await?
            .ok_or(WorkflowArtifactError::NotFound)
    }

    /// Find all artifacts for a workflow
    pub async fn find_by_workflow(
        pool: &SqlitePool,
        workflow_id: Uuid,
    ) -> Result<Vec<Self>, WorkflowArtifactError> {
        let artifacts = sqlx::query_as::<_, WorkflowArtifact>(
            r#"
            SELECT * FROM workflow_artifacts
            WHERE workflow_id = ?1
            ORDER BY artifact_type, created_at DESC
            "#,
        )
        .bind(workflow_id)
        .fetch_all(pool)
        .await?;

        Ok(artifacts)
    }

    /// Find artifacts by type for a workflow
    pub async fn find_by_workflow_and_type(
        pool: &SqlitePool,
        workflow_id: Uuid,
        artifact_type: ArtifactType,
    ) -> Result<Vec<Self>, WorkflowArtifactError> {
        let type_str = artifact_type.to_string();
        let artifacts = sqlx::query_as::<_, WorkflowArtifact>(
            r#"
            SELECT * FROM workflow_artifacts
            WHERE workflow_id = ?1 AND artifact_type = ?2
            ORDER BY created_at DESC
            "#,
        )
        .bind(workflow_id)
        .bind(&type_str)
        .fetch_all(pool)
        .await?;

        Ok(artifacts)
    }

    /// Get summaries of all artifacts for a workflow
    pub async fn summaries_by_workflow(
        pool: &SqlitePool,
        workflow_id: Uuid,
    ) -> Result<Vec<WorkflowArtifactSummary>, WorkflowArtifactError> {
        let artifacts = Self::find_by_workflow(pool, workflow_id).await?;
        Ok(artifacts
            .into_iter()
            .map(|a| WorkflowArtifactSummary {
                id: a.id,
                artifact_type: a.artifact_type,
                title: a.title,
                file_url: a.file_url,
                created_at: a.created_at,
            })
            .collect())
    }

    /// Count artifacts by type for a workflow
    pub async fn count_by_workflow(
        pool: &SqlitePool,
        workflow_id: Uuid,
    ) -> Result<std::collections::HashMap<String, i64>, WorkflowArtifactError> {
        #[derive(FromRow)]
        struct TypeCount {
            artifact_type: String,
            count: i64,
        }

        let counts = sqlx::query_as::<_, TypeCount>(
            r#"
            SELECT artifact_type, COUNT(*) as count
            FROM workflow_artifacts
            WHERE workflow_id = ?1
            GROUP BY artifact_type
            "#,
        )
        .bind(workflow_id)
        .fetch_all(pool)
        .await?;

        Ok(counts
            .into_iter()
            .map(|c| (c.artifact_type, c.count))
            .collect())
    }

    /// Delete an artifact
    pub async fn delete(pool: &SqlitePool, id: Uuid) -> Result<(), WorkflowArtifactError> {
        let result = sqlx::query(r#"DELETE FROM workflow_artifacts WHERE id = ?1"#)
            .bind(id)
            .execute(pool)
            .await?;

        if result.rows_affected() == 0 {
            return Err(WorkflowArtifactError::NotFound);
        }

        Ok(())
    }

    /// Delete all artifacts for a workflow
    pub async fn delete_by_workflow(
        pool: &SqlitePool,
        workflow_id: Uuid,
    ) -> Result<u64, WorkflowArtifactError> {
        let result = sqlx::query(r#"DELETE FROM workflow_artifacts WHERE workflow_id = ?1"#)
            .bind(workflow_id)
            .execute(pool)
            .await?;

        Ok(result.rows_affected())
    }
}
